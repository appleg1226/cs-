 리팩터링 (마틴파울러)
 
2장. 리팩터링 원칙

- 리팩터링의 뜻
소프트웨어의 겉보기 동작은 그대로 유지한 채, 여러가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하는 것.

- 리팩터링은 성능을 좋게 만드는 것이 목적이 아니다.
리팩터링의 목적은 코드를 이해하고 수정하기 쉽게 만드는 것이다.
성능 최적화와는 거리가 멀다.

- 리팩터링의 장점
1. 소프트웨어 설계가 좋아진다.
2. 소프웨어를 이해하기 쉬워진다.
3. 버그를 쉽게 찾을 수 있다.
4. 프로그래밍 속도를 높일 수 있다.

- 3의 법칙(3 strike rule)
1. 처음에는 그냥 한다.
2. 비슷한 일을 만나면 일단은 진행한다.
3. 비슷한 일을 세 번째 만나는 순간 리팩터링 한다.

- 리팩터링은 계획된 과정이 아닌 수시로 하는 과정이 되어야 한다.

- 리팩터링을 하지 말아야 할 때
1. 지저분해도 굳이 수정할 필요가 없다면 하지 않는다.
2. 처음부터 새로 작성하는 것이 쉬울 때도 하지 않는다.

- 리팩터링은 도덕적 실천 문화가 아닌 경제적이고 실용적인 도구이다.

- 레거시 코드를 해결할 때 보통 리팩터링을 하게 된다.
이때는 프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다.
그리고 자주 보이는 부분을 우선적으로 리팩터링한다.

- YAGNI(You aren't going to need it)
설계를 처음부터 빡세게 적용하지 말고, 점진적으로 변경해나가자는 설계.
아키텍처의 변경을 리팩터링을 뒷받침하여 유연하게 진행한다.
처음에 정해진 아키텍쳐들은 언제든 바뀔 가능성이 크기 때문에 염두해두고 리팩터링을 하며 개발한다.

- 테스트코드 + 지속적 통합(CI) + 리팩터링 + YAGNI

- 리팩터링을 하면 소프트웨어는 느려질 수 있지만, 성능 튜닝을 하기는 더 쉬워질 것이다.
1. 리팩터링을 하면 성능 튜닝에 집중할 시간을 벌 수 있다.
2. 리팩터링이 잘 되어 있는 시스템은 성능을 더 세밀하게 분석할 수 있다.

======================================================================
3장. 코드에서 나는 악취
- 기이한 이름
- 중복 코드
- 긴 함수
- 긴 매개변수 목록
- 전역변수
- 가변데이터
- 뒤엉킨 변경: 기능을 추가/수정하는데 여러 부분을 고쳐야하는 경우
- 기능 편애: 프로그램은 영역 안에서 상호작용을 늘리고, 영역 간의 상호작용은 줄이는 것이 좋은데
                     이에 맞지 않게 자기보다 다른 것을 더 많이 사용하는 것을 말한다.
- 데이터 뭉치: 데이터 필드 여러개가 뭉쳐다니는 상황
- 기본형 집착: 기본형을 사용하는 것에 대한 집착(int, String 등)
- 반복되는 switch문
- 반복문
- 성의 없는 요소: 굳이 클래스/인터페이스를 남용하는 경우
- 추측성 일반화: 너무 예민하게 미래를 대비하는 코드
- 임시 필드
- 메시지 체인: 한 객체로부터 getter를 너무 여러번 호출하는 것.
- 중개자: 지나친 위임
- 내부자 거래
- 거대한 클래스
- 서로 다른 인터페이스의 대안 클래스들
- 데이터 클래스
- 상속 포기
- 주석

======================================================================
6장. 기본적인 리팩터링

- 함수 추출하기
'특정 로직 단위를 static 함수로 빼낸다.'
주로 함수가 길 때 나눌 때 많이 사용한다.
이것은 해당 행동을 메서드 이름을 설명할 수 있어, 어떤 행동을 하는지 파악하는 데에 도움이 된다.
대신 이름 짓기에 신경을 잘 써야 한다.

반환할 값이 여러개라면 묷어서 반환하는 것도 괜찮지만,
각 반환을 하는 함수 여러 개를 만드는 것도 괜찮다.

- 함수 인라인하기
'변수 선언 -> 선언된 변수 사용을 하는 것이 아닌 선언과 동시에 사용하는 법'

- 변수 추출하기(함수 인라인하기와 반대)
'복잡한 표현식을 명확한 이름을 가진 변수를 이용해서 대체해주는 방법'
ex) (do something) + (do something2) * (do something3)
   => d1 + d2 * d3(이름은 자세하게 설정) 

- 함수 선언 바꾸기
'함수 이름 명확하게 바꾸기', '매개변수 추가/제거'

- 변수 캡슐화하기
'getter, setter를 이용하기'
getter를 이용할 때는 특히 필드가 변경될 수 있는 것들은 복제본을 반환해주는 것도 좋다.

- 변수 이름 바꾸기
'명확한 이름짓기'

- 매개변수 객체 만들기
'여러 개의 매개 변수를 하나의 클래스로 묶기'

- 여러 함수를 클래스로 묶기
'공통 데이터를 중심으로 엮여 작동하는 함수를 하나의 클래스로 묶기'
비슷한 작업이 많아지면 클래스로 묶고 데이터도 캡슐화를 해서 쓰자.

- 여러 함수를 변환 함수로 묶기
'어떤 값을 여러 번 변환해야할 경우 그것을 하나의 함수에서 모아서 처리하기'

- 단계 쪼개기
'긴 함수를 여러 단계의 메서드로 쪼개서 관리하는 방법'

======================================================================
7장. 캡슐화
- 레코드 캡슐화하기
'json 같은 레코드 파일들을 클래스로 캡슐화해서 쓸 것'

- 컬렉션 캡슐화하기
'컬렉션을 직접 다루게 하지 말고, add-remove 등을 메서드로 호출하도록 하기'

- 기본형을 객체로 바꾸기
'특정 도메인 변수를 String 같은 것으로 쓰지 말고 객체로 만들기'
예를 들면 전화번호를 그냥 String으로 쓰기보다는, PhoneNumber 객체로 바꿔서 쓸 것.
나중에 기능 추가에 효과적이다.

- 임시 변수를 질의 함수로 바꾸기
int c = a*b 이거를 
static int getC(int a, int b){ return a* b; }  이런식으로 바꾸는 것이다.

- 클래스 추출하기
'하나의 클래스가 너무 많은 역할을 처리할 때, 이것을 다른 클래스로 나누어 처리하는 것'
사람 클래스의 내부 필드 중에 전화번호가 있는데, 여기에서 처리할 것이 많고
사람 클래스가 복잡한 상황이라면, 전화번호를 다른 클래스로 빼는 것이 좋다.

- 클래스 인라인하기 (<=> 클래스 추출하기)
'클래스가 나뉠 필요가 없을 때 합치는 것' 
위의 개념과 반대다.
굳이 쓸모가 없는 클래스를 나눌 필요는 없다.

- 위임 숨기기
'클라이언트가 어떤 메서드를 사용할 때 그 내부 구조를 몰라도 호출할 수 있도록 하는 것'
클라이언트는 어떤 필드의 내부 객체를 호출할 때 그 내부를 알아야할 필요가 없다.
그리고 알면 안 된다.
그래서 사용하려면 그 내부에 접근할 수 있는 메서드를 만들어 준다.

- 중개자 제거하기 (<=> 위임 숨기기)
'중개자를 너무 자주 호출할 경우에는 직접 호출할 수 있도록 한다.'
굳이 가리기엔 너무 자주 호출하는 상황이라면 숨기지 않는 것이 좋을 수도 있다.
위의 위임 숨기기와 상황에 맞게 판단해야 한다.

- 알고리즘 교체하기
'알고리즘 자체를 바꾸는 것도 리팩토링이다'
전체적인 동작 로직 자체를 바꾸는 것

======================================================================
8장. 기능 이동


======================================================================
9장. 데이터 조직화


======================================================================
10장. 조건부 로직 간소화


======================================================================
11장. API 리팩터링


======================================================================
12장. 상속 다루기


















































