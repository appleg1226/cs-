이펙티브 자바(조슈아 블로크 지음)

이 책은 내가 최근에 읽었던 책 중에서 제일 재미있고 유용했다.
내가 이미 알고있는 자바에 대하여 더더욱 심화적인 부분을 알려줘서 업그레이드 되는 기분이 일단 좋다.
그리고 적당히 난이도가 있고 기본 지식이 필요해서 지금까지 공부하면서 느낀 것들이 뿌듯하기도 하다.

그러나 결국은 이 책은 사전이라고 봐야할 것 같다.
필요할 때마다 두고두고 꺼내봐야할 그런 지식들.

그래서 가끔씩 이 글들을 보면서, 프로젝트를 시작하기 전에 한 번 목차를 쭉 둘러보면
큰 도움이 될 것이라고 생각한다.

사람들이 하도 블로그에 잘 정리해놔서, 해당 아이템 제목만 쓰면 금방 기억에 날 듯 하다.

===========================================================================

<2장 객체 생성과 파괴>
*아이템1*) 생성자 대신 정적 팩터리 메서드를 고려하라
Date d = Date.from(instant);
Set<Rank> faceCards = EnumSet.of(jack, queen, king);
같이 새로운 객체를 생성자를 통해서 만들지 않고, static method로 만들면,
때때로 유연한 구성을 가능하게 해 준다.

아이템2) 생성자에 매개변수가 많다면 빌더를 고려하라
LOMBOK.

아이템3) private 생성자나 열거 타입으로 싱글턴임을 보장하라
싱글턴을 만들 때는 아이템3을 보고 만들자(검색해보면 바로 나옴)

아이템4) 인스턴스화를 막으려거든 private 생성자를 사용하라
private 생성자를 쓰면 인스턴스화, 상속이 다 막혀서 편리하다.
util 클래스에 사용하면 좋다.

아이템5) 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라
어떤 유틸클래스를 쓸 때 내부 구현을 여러 가지로 사용해야할 때가 있다.
이럴 때는, 생성자로 내부 구현을 이루고 있는 또는 팩토리 메서드를 주는 것이 좋다.
Mosaic create(Supplier<? extends Tile> tileFactory) {...}
간단한 것은 위와 같은 식으로 직접 함수형인터페이스로 받아도 괜찮다.

아이템6) 불필요한 객체 생성을 피해라
값비싼 객체는 재활용하라. 
불필요한 오토박싱/언박싱도 손해다.

아이템7) 다 쓴 객체 참조를 해제하라
null 처리를 하는 것도 좋지만, 필요한 상황에 예외적으로 실행하는 것이 좋다.
전체적으로 메모리 누수를 야기할 수 있는 것들(캐시, 콜백, 리스너)들을 잘 대비해야 한다.

*아이템9*) try-with-resources를 사용하라
try()안에는 autoclosable을 구현한 자원이 들어가야 한다.
자동으로 해제해주고, 코드도 깔끔해진다.

===========================================================================
<3장 모든 객체의 공통 메서드>
아이템10) equals는 규약을 지켜 재정의하라
길게 말하지만, equals는 꼭 필요할 때만 재정의할 것.
그리고 정의한다면 철저하게 정의할 것.

아이템11) equals를 재정의하려거든 hashcode도 재정의하라: LOMBOK.

아이템12) toString을 항상 재정의하라

아이템13) clone 재정의는 주의해서 진행하라

아이템14) Comparable을 구현할지 고려하라.
a.value-b.value 이런거보다 자바에서 제공하는 비교자 생성 메서드를 이용하라.

===========================================================================
<4장 클래스와 인터페이스>
아이템15) 클래스와 멤버의 접근 권한을 최소화하라
public 클래스의 인스턴스 필드는 되도록 private으로 하라.(명령!)

*아이템17*) 변경 가능성을 최소화하라
불변 클래스는 내부의 구성요소들이 불변성을 유지하는 객체다.
즉 final이 붙어있는 것들을 말하는데, 이렇게하면 동시성 측면 등에서 안정성이 올라가게 된다.
꼭 필요한 경우가 아니면 불변으로 만드는 것이 좋다.
즉 꼭 필요한 상황이 아니면 웬만하면 final을 붙이는 습관을 들이자.
이건 kotlin이나 다른 언어에서 val(const)를 쓰는 것과 비슷한 맥락이라고 본다.

*아이템18*) 상속보다는 컴포지션을 이용하라
상속은 상위 클래스에 의존하기 때문에 불안전하다. 상위 클래스가 바뀌면 어떡할텐가..
그러므로 이에 대해서는 Decorator 패턴을 이용한 래퍼 클래스를 사용하는 것이 훨씬 좋으며 단점도 거의 없다.
Set<Instant> times = new InstrumentedSet<>(new TreeSet<>(cmp))
instrumentedset은 여기엔 없지만 forwardingSet을 확장한 클래스이며 생성자로 구체적 구현체를 받아서 쓴다.

아이템19) 상속을 고려해 설계하고 문서화하라. 그렇지 않았다면 상속을 금지하라
위와 연결된 내용이다. 상속용 클래스를 만드는 것은 매우 어려운 일이고, 만들었을 경우에도 상속한 사람들이
어떻게 사용해야하는지에 대하여 설명과 고려가 있어야 한다. 이런 점에서 굳이 상속을 할 필요가 없다면,
금지하는 것이 나을 것이다.

*아이템20*) 추상 클래스보다는 인터페이스를 우선하라
일반적으로 다중 구현용으로는 인터페이스가 가장 적합하다. 그러나 복잡한 인터페이스라면 default를 사용하여
구현을 제공할 수도 있다. 이외에도 추상클래스와 인터페이스의 장점을 동시에 취할 수 있는 방법이 있는데,
템플릿 메서드 패턴을 이용한 '골격 구현 클래스'이다. 
abstract class AbstractMapEntry<K, V> implements Map.Entry<K, V> 처럼 인터페이스를 구현하고
내부적으로 반드시 구현해주어야할 것들을 구현해 놓는 것이다.

아이템21) 인터페이스는 구현하는 쪽을 생각해 설계하라
인터페이스에 기능을 추가하려하면, default 메서드를 추가하면 되는데, 이것이 문제가 없는 것이 아니다.
처음부터 주의해서 설계할 것.

아이템22) 인터페이스는 타입을 정의하는 용도로만 사용하라(안에다 상수좀 넣지 마라..)

아이템23) 태그 달린 클래스보다는 클래스 계층구조를 사용하라
한 클래스에서 여러 개의 계층을 표현하는 것을 태그 달린 클래스라고 표현했다.
계층 구조는 그냥 상속 구조로 만들어라...

아이템24) 멤버 클래스는 되도록 static으로 만들어라.
멤버 클래스가 바깥 인스턴스를 참조할 것이 아니면 static으로 만들어라.

아이템25) 톱레벨 클래스는 한 파일에 하나만 담으라
소스파일 하나엔 클래스 하나만^^

===========================================================================
<5장 제네릭>
아이템26) 로 타입은 사용하지 말라: 런타임 에러가 일어난다. 근데 요샌 로타입 원래 안 쓴다.

아이템27) 비검사 경고를 제거하라: 이것도 인텔리제이가 신경써주며 잘 돼 있는 듯.

아이템28) 배열보다는 리스트를 사용하라: 제네릭 덕분에 안정적이다.

아이템29) 이왕이면 제네릭 타입으로 만들라: 안전하고 편하다.

아이템30) 이왕이면 제네릭 메서드로 만들라: 위와 동일.

아이템31) 한정적 와일드 카드를 사용해 API 유연성을 높이라
한정적 타입이란 Object<?> 처럼 물음표로 한정을 짓는 것이 많은 것을 담게 할 수 있다.
여기에 <? extends E> 또는 <? super E> 같은 것들을 조합하면 안정적이고 편리하게 쓸 수 있다.

아이템32) 제네릭과 가변인수를 함께 쓸 때는 신중하라
가변인수는 method(List<String> ... stringLisgs) 처럼 저 쩜쩜쩜이 붙은건데,
저게 그렇게 궁합이 좋지도 않고 타입 안정성도 떨어진다.
그냥 웬만하면 List.of() 같은 정적 팩토리 메서드 같은 것을 써서 넘기자.

아이템33) 타입 안전 이종 컨테이너를 고려하라
Map<Class<?>, Object> 같이 만든 것을 '타입안전이종컨테이너' 라고 한다.
이렇게 해버리면 타입에 따라서 쓸 수가 있다.
디비 같은 데에서 한 항목에 여러 타입을 쓸 때 편리한데, 이건 필요한 상황이 많을 것 같지는 않다.

이번 장을 정리하자면 '자바 사용자라면 웬만하면 Generic 씁시다!' 
정도로 요약할 수 있을 듯. 

===========================================================================
<6장 열거타입과 어노테이션>
아이템34) int 상수 대신 열거 타입을 사용하라
public static final int APPLE = 10;(x)
enum fruit{ APPLE }(o)

아이템35) ordinal 메서드 대신 인스턴스 필드를 사용하라
ordinal이 몰라서 쓸 생각도 안해봤다.
enum{
	APPLE(10), BANANA(15)
}  이런 식으로 써라.

아이템36) 비트 필드 대신 EnumSet을 사용하라
비트 연산을 쓸 때는 EnumSet을 쓰면 깔끔하고 좋다.

아이템37) ordinal 인덱싱 대신 EnumMap을 사용하라
Enum을 쓰고 map을 사용하려 한다면 EnumMap이 성능이 압도적으로 좋을 것이다.

아이템38) 확장할 수 있는 열거 타입이 필요하다면 인터페이스를 사용하라
enum 타입은 interface도 구현할 수 있다(wow)
이것을 통해서 확장도 자유롭게 할 수 있다만, 제한적이긴 하다. 필요하면 쓸 것.

아이템39) 명명 패턴보다 애너테이션을 사용하라
이건 리플렉션 관련 얘기로 넘어가게 되는데, 원래는 메서드 이름으로 뭔가를 확인했던 시절이 있었다.
junit 4 이전에는 test로 시작하는 메서드를 찾아서 테스트를 했다고 한다.
지금은 어노테이션을 너무 대중적으로 쓰기에 옛 얘기가 돼 버렸다.

아이템40) @Override 애너테이션을 일관되게 사용하라: ok.

아이템41) 정의하려는 것이 타입이라면 마커 인터페이스를 사용하라
마커 인터페이스는 어노테이션처럼 해당 클래스를 설명해주는 인터페이스다.
serializable 같은 것들을 말하는데, 어노테이션과 비슷하다 생각할 수 있지만,
또 타입을 제한시켜주는 좋은 효과가 있어서 어노테이션과 필요에 따라 사용해야 한다.

===========================================================================
<7장 람다와 스트림>
아이템42) 익명 클래스보다는 람다를 사용하라
익명 클래스는 함수형 인터페이스가 아닌 타입의 인스턴스를 만들 때만 쓰고,
웬만하면 람다 씁시다~

아이템43) 람다보다는 메서드 참조를 사용하라: 람다보다 더 가독성이 있어서 좋다

*아이템44*) 표준 함수형 인터페이스를 사용하라
연습이 필요한 코드긴 하지만, 매력적이라고 생각하고 자주 사용해 볼 생각이다.
덕분에 자바에서 함수형 프로그래밍이 더욱 가능하게 되었다.

아이템45) 스트림은 주의해서 사용하라: 반복문과 둘 다 써보고 상황에 맞게 실질적인 것을 잘 고를 것

아이템46) 스트림에서는 부작용 없는 함수를 사용하라
애초에 스트림은 함수형 프로그래밍을 위한 도구이다.
forEach문은 웬만하면 결과 출력 정도에만 쓰자

아이템47) 반환 타입으로는 스트림보다 컬렉션이 낫다: OK

아이템48) 스트림 병렬화는 주의해서 적용하라
parallel은 항상 성능을 향상시켜주지 않는다. 오히려 성능이 떨어지거나 오작동 할 수도 있다.
그리고 중간 연산이 parallel을 방해하는 연산들이 많아도 안 된다.
제대로 쓰고 싶다면 spliterator 같은 것을 재정의해서 사용하면 된다.
항상 써보고 성능 체크를 할 것.

===========================================================================
<8장 메서드>
아이템49) 매개변수가 유효한지 검사하라
요새는 @NonNull 같은 것도 많이 나왔다. 이렇게 매개변수들을 확인하고 거르면 도움이 많이 된다.

아이템50) 적시에 방어적 복사본을 만들라
매개변수나 반환결과가 가변적인 변수일 경우 이것을 수정할 수 있는 문제가 생긴다.
이것을 방지하기 위하여 각 메서드에서 객체 참조 고리를 풀어주어야 한다.
그러나 제일 좋은 것은 애초에 이런 상황을 만들지 않도록 하는 것이 아닐까.
최대한 추상화로 감추는 것이 좋은 것 같다.

아이템51) 메서드 시그니처를 신중히 설계하라
- 메서드 이름은 신중히
- 편의 메서드는 적당히 만들자
- 매개변수 목록은 짧게 유지하자
- 매개변수로는 클래스보다 인터페이스가 낫다
- boolean보다는 원소 2개짜리 열거 타입이 낫다.

아이템52) 다중정의(Method overloading)는 신중히 사용하라
메서드의 이름을 차라리 다르게 지어라.
생성자의 경우에도 그냥 정적 팩토리 메서드로 처리하자.

아이템53) 가변인수는 신중히 사용하라
유용하지만 성능적으로 호출될 때마다 배열을 할당하고 초기화하기때문에 무겁다.
이럴 때는 
public void foo(){}
public void foo(int a1){}
public void foo(int a1, int a2, int a3){}
public void foo(int a1, int a2, int a3, int... rest){}
요런 식으로 나눠줘도 괜찮다.

아이템54) null이 아닌, 빈 컬렉션이나 배열을 반환하라
null을 반환하는 API는 사용이 어렵고 오류처리가 늘어난다. 그렇다고 성능이 좋은 것도 아니다.

아이템55) 옵셔널 반환은 신중히 하라
성능적으로 그렇게 좋은 메서드가 아니다. 차라리 null이 나을 수도 있을 정도이다.
그냥 예외로 던지자.

아이템56) 공개된 API 요소에는 항상 문서화 주석을 작성하라
공개 api를 만드려면 javadoc 기준을 준수하여 제대로 만들어라.

===========================================================================
<9장 일반적인 프로그래밍 원칙> 
아이템57) 지역변수의 범위를 최소화하라: 지역변수 헷갈리지 않게 필요한 곳에만 잘 넣어라.

아이템58) 전통적인 for문보다는 for-each문을 사용하라
지역변수를 쓰면서 틀릴 가능성이 더 높아진다. 성능 차이도 없으니 적극 사용하라.

*아이템59*) 라이브러리를 익히고 사용하라
- 메이저 릴리즈마다 주목할만한 라이브러리는 챙겨볼 것
- java.lang, java.util, java.io, java.util.concurrent, 컬렉션프레임워크
  얘네들은 무조건 한 번 씩은 볼 것!!!

아이템60) 정확한 답이 필요하다면 float와 double은 피하라: BigDecimal을 쓸 것.

아이템61) 박싱된 기본 타입보다는 기본 타입을 사용하라
웬만하면 기본타입을 써라. 문제가 많이 생긴다.
필요없는 객체를 굳이 만들 필요가 없다.

아이템62) 다른 타입이 적절하다면 문자열 사용을 피하라
문자열보단 열거형을 쓰거나 클래스로 쓰거나 해라. 

아이템63) 문자열 연결은 느리니 주의하라: StringBuffer, StingBuilder OK?

아이템64) 객체는 인터페이스를 사용해 참조하라: 넵

아이템65) 리플렉션보다는 인터페이스를 사용하라
리플렉션은 컴파일의 이점도 없고, 지저분해지고, 성능도 떨어진다.
일반적인 상황에서는 굳이 리플렉션을 열심히 쓸 필요는 없을 것이다.

아이템66) 네이티브 메서드는 신중히 사용하라

아이템67) 최적화는 신중히 하라
최적화를 할 때는 다음 두 규칙을 따르라.
첫 번째, 하지 마라.
두 번째, (전문가 한정) 아직 하지 마라. 다시 말해, 완벽히 명백하고 최적화되지 않은 해법을 찾을 때
까지는 하지 마라. - M.A 잭슨
재미있어서 가져와봤다. 성능에 문제가 있는 부분만 줄여도 충분하다.
좋은 코드가 빠른 코드가 된다.

*아이템68*) 일반적으로 통용되는 명명 규칙을 따르라
다른 코드들에서, 특히 자바가 명명하는 규칙을 비슷하게 따르는게 여러모로 좋다.
누구나 봤을 때 위화감이 확실히 적을 것이다.

===========================================================================
<10장 예외>
아이템69) 예외는 진짜 예외 상황에만 사용하라
예외는 흐름제어용이 아니다. 성능이 많이 느려진다.

아이템70) 복구할 수 있는 상황에는 검사 예외를, 프로그래밍 오류에는 런타임 예외를 사용하라
throwable 이런거 쓰지 마라. 웬만하면 RuntimeException을 써라.

아이템71) 필요 없는 검사 예외 사용은 피하라
옵셔널도 고민해봐라.

아이템72) 표준 예외를 사용하라
Exception, RuntimeException, Throwable, Error 이거 직접 쓰지 마라.

아이템73) 추상화 수준에 맞는 예외를 던지라
아래 계층의 예외를 올릴 때는 예외를 돌려서 올려라(예외 번역이라고 부른다.)
어떤 예외 A를 받았을 때 예외 B를 날린다. 이런식으로 하면 된다.

아이템74) 메서드가 던지는 모든 예외를 문서화하라: 넵

아이템75) 예외의 상세 메시지에 실패 관련 정보를 담으라: 넵

아이템76) 가능한 한 실패 원자적으로 만들라
원자적이란 것은 Atomic하다고 보면 된다.
실패가 트랜잭션처럼 특정 상태 변경을 하지 말아야 한다는 것이다.
이를 위해서라면 예외를 앞에서 두고, 변경을 뒤로 하면 될 것 같다.
아니면 finally에서 되돌리거나.
아니면 임시 객체에서 진행하고 원래 객체에 넣는 방법도 있다.

아이템77) 예외를 무시하지 말라
catch를 비우지 마라!

===========================================================================
<11장 동시성>
아이템78) 공유 중인 가변 데이터는 동기화해 사용하라
가변 데이터는 웬만하면 멀티스레드에서 쓰지 마라. 
불변만 사용할 것. 아니면 Atomic을 쓸 것.ㅣ

아이템79) 과도한 동기화는 피하라

아이템80) 스레드보다는 실행자, 태스크, 스트림을 애용하라: ExecutorService 이용

아이템81) wait와 nofity보다는 동시성 유틸리티를 애용하라
ConcurrentHashMap을 사용하고,
CountDownLatch, Semaphore, CyclicBarrier, Exchanger, Phaser를 고려해보자.

아이템82) 스레드 안정성 수준을 문서화하라

아이템83) 지연 초기화는 신중히 사용하라
그냥 대부분은 곧바로 초기화하는 것이 좋다.

아이템84) 프로그램의 동작을 스레드 스케줄러에 기대지 말라
실행 가능한 스레드의 평균적인 수를 프로세서 수보다 지나치게 많아지지 않도록 하자.
busy waiting 상태가 되지 않도록 하자.

===========================================================================
<12장 직렬화>
아이템85) 자바 직렬화의 대안을 찾으라
Json, protobuf를 사용하자.

아이템86) Serializable을 구현할지는 신중히 결정하라
그냥 구현하지 않는게 맞다고 한다. 보안 위험 때문에.

아이템87) 커스텀 직렬화 형태를 고려해보라
아이템88) readObject 메서드는 방어적으로 작성하라
아이템89) 인스턴스 수를 통제해야 한다면 readResolve보다는 열거 타입을 사용하라
아이템90) 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라

이번 장은 직렬화를 제대로 써 본적이 없어서 적당히 읽고 넘겼다.
나중에 필요할 때 다시 한 번 확인해보면 좋을 것 같다.



































