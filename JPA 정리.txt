JPA의 내부 원리

JPA는 사용하는 입장에서 보는 방식과,
실제로 내부적으로 구동하는 두 방식을 이해하는 것이 필요하다.

기본적인 CRUD 기능을 익히기 위해서는 Spring Data JPA의 레퍼런스 문서만 읽어도
쉽게 구현이 가능하다.

1. DB 셋팅 및 Spring 설정
2. CrudRepository 를 상속하는 인터페이스 선언
3. 해당 Repository를 Autowired로 주입받아 API 사용

또한 다음의 추가 설정만으로 간단한 JPA 이용이 가능하다.

추가적으로 할 수 있고 해야하는 것이 있다면,
1. Entity에 대한 설정
2. Entity 간의 관계에 대한 매핑 설정
3. @Transactional 의 적절한 사용

---

이 정도의 사용방법을 알았다면 그 다음은 과연 그 내부의 구현이 어떻게 이루어져있는지를 확인할 때다.

우리가 가장 가깝게 마주하는 Spring Data JPA는 껍데기에 가깝다.
내부적으로는 몇 단계의 구현이 되어있는지 알아보자.

크게 보아서 JPA - Hibernate - Spring Data JPA 이렇게 세 단계로 볼 수 있을 것 같다.
1. JPA: JPA는 명세이다. 구현체가 아니기 때문에 이 JPA를 구현한 프레임워크가 필요하다. 
2. Hibernate: Hibernate는 JPA를 구현한 구현체인 프레임워크다. 하이버네이트만 있다면 사실상 JPA의 모든 기능을 사용할 수 있다. 많은 구현체가 있지만 Spring은 이걸 이용한다.
3. Spring Data JPA: 스프링 환경에서 사용하기에 특화된 모듈이다. hibernate를 사용한다면 entityManager를 이용해서 구현해야 했던 JPA를 Spring 만의 고도로 추상화된 방식으로 사용할 수 있게 해 준다. 

결국 Spring Data JPA의 레퍼런스만 보아도 사용하는 데에 크게 문제는 없지만, 실제로 JPA의 구동 방식을 이해하려면 결국 적어도 Hibernate에 대하여 이해할 필요는 있다.

---

Lazy Loading, Eager Loading, Fetch Join, N+1 문제, 트랜잭션 처리 등
JPA에서만 등장하는 각종 용어들이나 현상을 글로만 얼추 이해하는 것은 어렵지 않았다.
아하 그렇구나....

그렇지만 이런 것들이 어떤 지식들을 기반으로 돌아가는지를 안다면 더 완벽하게 이해가 가능하다.

그러기 위해서는 다음의 것을 알아야 한다.
'영속성 컨텍스트(Persistence Context)' 

솔직히 말해서 뭔소린가 싶다. 영속이라함은 영원히 지속된다 이런 의미인데,
DB 공부하면서 느끼는 건데 저장하면 그냥 저장하는 거지, 영구히 저장하는 것과 무엇이 다른가 싶다.
그래서 이 용어는 정확하게 이해하기는 어려울 것 같고,
책의 설명을 비슷하게 인용하고자 한다.
'엔티티를 영구 저장하는 환경' 이라고 설명한다.

엔티티를 저장하는 공간이 즉 '영속성 컨텍스트'이다.
우리가 JPA를 사용하면서 선언한 Entity들은 모두(대부분) 이 컨텍스트 안에서 관리가 된다.

간단하게 말해서 데이터들을 저장하는 저장소 또는 DB가 영속성 컨텍스트다.
내부의 1차 캐시라는 곳에서 관리가 되고 있다.

더 간단하게 그냥 메인 DB를 내 자바 프로그램에서 캐시해놓고 있다고 보면 된다. 

JPA의 동작은 이 영속성 컨텐츠를 DB와의 가운데 두고 이루어 진다.
Spring(JPA) - PersistenceContext - DB(Mysql)

---

JPA가 기존 쿼리를 날리던 방식과 다른 점이라면 DB에 곧바로 쿼리를 날리지 않는다는 것이다.

기존 JDBC 에서는 쿼리를 만들면 바로 DB에 그 쿼리를 실행시키도록 했다. 
즉 자바 어플리케이션 자체로는 그냥 코드에 있는 쿼리를 DB에 전달해줄 뿐이었다.
단순한 통신의 기능을 했을 뿐이다.

그러나 JPA는 다르다.
JPA가 JDBC와 다른 점은 단순히 쿼리를 만드는 것에서 끝나지 않는다는 점은 이 기술의 매력이기도 하다.

JPA는 내가 객체지향적으로 만들어 놓은 Entity들에 대한 정보들, 그리고 각종 쿼리들을 
파싱하는 등 자체적으로 처리를 하는 기능들로 이루어져 있다.
단순히 쿼리를 전달하는 것 이상으로 자체적으로 무엇인가를 많이 한다.
성능적인 이슈, DB의 정확성을 위한 이슈 등을 자체적으로 조절하는 환경이 마련되어 있다.

그 JPA가 저장소로 이용하는 것이 바로 영속성 컨텍스트다.

---
엔티티의 생명주기

내가 만든 엔티티는 EntityManager의 부름을 받으면 비로소 생명이 생긴다.
즉 내가 아무리 클래스를 만들고 그것을 객체로 만든다한들, 여전히 데이터베이스에 저장할 상태가 된 것은 아니다.

em.persist() 메서드를 통하여 Managed 상태가 된다면 그때부터 데이터베이스에 저장될 준비가 된 것이다. em.persist를 이용하여 내 객체를 저장하면 그 때 비로소 하나의 데이터가 된다.

그렇지만 아직 이대로는 데이터가 DB로 전달된 것은 아니다.
managed 상태의 데이터는 나의 영속성 컨텍스트라는 자체 캐시에서만 관리가 되고 있다.

물론 이 Managed 상태를 해제하는 것도 가능하다.
아예 remove()를 이용하여 없애버릴 수도 있고,(removed)
detach()를 이용하여 관리를 해제할 수도 있다.(detached, 준영속)

이렇게 영속성 컨텍스트에 등록하든, 해제하든 없애든 나의 작업들을 실행한 뒤에 그것을
데이터베이스에 Flush하면 그제서야 JPA와 DB의 동기화가 시작된다.

동기화가 시작되면 내 영속성 컨텍스트와 실제 DB의 데이터를 분석하여
수정된 엔티티를 찾아 쿼리를 만들고, 그것을 실제 DB에 반영하게 된다.

---
영속성 컨텍스트가 관리할 때의 장점
1. 1차 캐시
JPA가 DB에 비해서 성능적으로 가질 수 있는 장점이 이 영속성 컨텍스트라는 점도 특이하다.
만약에 내가 DB에서 데이터를 읽고자 할 때, 그것을 매번 DB에서 읽어오는 작업을 한다면,
그것은 시간이 많이 들어가는 작업이다.

하지만 JPA에서는 이미 동기화된 영속성 컨텍스트에 내가 찾고자 하는 데이터가 있다면,
그 캐시에서 데이터를 가져오게 된다.
결국 I/O에 대한 문제를 메모리를 통하여 해결할 수 있으니 성능상 이점이 크다. 

2. 동일성 보장
내가 영속성 컨텍스트에서 관리하는 특정 객체를 불러오고자 한다면,
언제 호출하더라도 그 객체들의 equals 메서드와 실제 객체의 주소조차도 일치함을 보장한다. 

3. 트랜잭션을 지원하는 쓰기 지연
보통 트랜잭션은 DB 내부의 작업으로 생각이 되지만, JPA는 내부적으로 트랜잭션을 처리한다.
그리고나서 DB에 처리한 트랜잭션을 실제로 처리하도록 쿼리를 보내는 식이다.

만약 직접 DB에 트랜잭션 명령을 실시간으로 적용하려고 하면, 
우선은 DB에 대한 lock이 문제다. 모든 명령들을 한줄한줄 실행하고, 그 I/O가 발생하는 시간동안
테이블에 락이 걸린다면 성능에 미치는 영향이 크다.

그렇지만 JPA를 이용하면 자체적으로 트랜잭션을 처리한 뒤, 그 쿼리문을 넘기는 식이기 때문에,
실제로 DB에서 트랜잭션을 처리하는 시간은 굉장히 짧다. 즉 lock이 걸리는 시간이 최소화된다.

동시에 트랜잭션을 처리하기에 용이한 것이다.

4. 변경 감지
영속성 컨텍스트 내에 저장된 객체의 내용이 바뀐다면 그것을 JPA에서 추적한다.
그리고 그 바뀐 내용을 토대로 Query를 새로 만들어 그것을 Flush하는 때에 DB에 보내게 된다.
내가 직접 Update 쿼리를 해주지 않아도, 객체만 바꾸면 알아서 바뀐다.

5. 지연 로딩
내가 읽기를 원하는 객체가 다른 테이블과 연관 관계 상태에 있다면?
그런 상황에서 내가 읽은 객체는 내부에 다른 엔티티의 객체도 다 불러와야 한다.

그런데 그렇게 하면 과연 성능적으로 좋을까?
내가 내 팀의 객체를 가져오는데 그 구성원들의 수가 만약 10만명이라면
내 영속성 컨텍스트에는 엄청난 수의 데이터가 몰리게 된다. 10만명을 당장 쓸 것도 아니기에...

그렇다면 그것을 바로 불러오지 않을 방법이 존재한다.
Lazy Loading이라는 방식을 이용하면 그 10만명의 목록을 필요할 때 가져올 수도,
필요없다면 가져오지 않을 수도 있다.

그 방식은 프록시라는 방법에 의해서 구현된다.

---
스프링에서의 영속성 컨텍스트는?

스프링에서는 Repository를 이용하여 추상화되어 사용이 된다.
사용자는 영속성 컨텍스트라는 것을 알 필요가 없기 때문에, 난 몰라도 되는 줄 알았다.

그렇지만 더 정확하게 사용하기 위해서는 스프링에서도 영속성 컨텍스트가 어떻게 동작하는지는
알아야 한다.

기본은 트랜잭션 단위로 컨텍스트가 관리된다.

보통 Service 메서드에서 Repository를 주입받은 뒤에, 각 메서드에 @Transactional 을 붙여서
사용하게 된다. 그게 기본 단위이다. 딱 그 메서드를 넘어가면 영속성 컨텍스트가 종료된다.

트랜잭션이 끝나면 플러시가 되어 DB와 동기화가 되고 영속성이 종료되는 것이다. 

---
지연로딩과 준영속 상태에서의 문제점

만약에 컨트롤러에서 서비스를 호출하고 난 뒤 특정 엔티티 객체를 반환받았다고 가정하자.
그리고 그 반환받은 객체를 사용하는 것은 문제가 되지는 않는다.

그러나 만약 연관된 객체가 내부에 있고, 이것이 Lazy Loading 방식이라면 문제가 발생한다.
이미 @Transactional 메서드를 빠져나오면서 영속성 컨텍스트가 종료되기 때문이다.
Lazy로 가져오기로 한 객체를 가져올 수가 없어 예외가 발생한다.

이외에도 변경감지에 대한 기능도 동작하지가 않는다.

이에 대한 해결책으로는 다음의 방법이 있다.
1. Eager Loading으로 변경: 가장 간단한 방법이다. 이 방법을 쓰면 이후에 바로 사용할 수 있다.

2. JPQL 패치조인: 페치조인을 사용하면 로딩할 엔티티를 선택해서 즉시 가져올 수 있다.

3. 강제 초기화: 가져올 엔티티를 get() 메서드를 @Transaction 메서드 안에서 호출한다.
이렇게 사용을 해버리면 자동으로 가져오게 된다. 이걸 파사드 계층을 하나 더 두어 사용해도 된다.

그렇다면 아예 영속성 컨텍스트를 확장하는 방법은 어떨까
이것도 가능하다.

OSIV라고 해서 Open Session In View 라는 용어이다.
이전에는 요청 당 트랜잭션이라고 해서 서블릿 요청 하나에 하나의 영속성 컨텍스트를 유지시키는 방법을 사용했다.

그러나 스프링의 OSIV에서는 이것보단 조금의 제한을 둔다.
우선 쓰기는 @Transactional 안에서만 처리하도록 하고,
나머지 읽는 동작은 나머지 계층에서 다 사용할 수 있게 하는 것이다.
영속성 컨텍스트가 살아있기 때문에 지연로딩도 가능하다.

---
N+1 문제
스프링을 쓰다가 보면 findAll 메서드를 호출해야할 일이 있는데, 이 때 가끔 문제가 있다.
OneToMany에 딸린 컬렉션이 엔티티에 들어있을 경우가 문제다.

findAll은 JPQL로 실행이 되는 메서드이다.
그런데 이 JPQL은 findAll을 실행할 때, eager나 lazy에 상관없이 본인의 방법대로 쿼리를 실행한다.
그러다보니 쿼리가 One 하나 실행되고, 그에 맞는 Many 쿼리가 개당 실행되는 식이다.

Eager 모드일 경우에는 이 N+1 쿼리가 실행이 바로 된다. 
이름이 왜 N+1 이냐면
1개의 One에 대한 select 쿼리와, n개의 Many에 대한 select 쿼리가 발생하기 때문이다. 

Lazy 모드일 경우에는, 그 객체를 실행하지 않으면 딱히 문제는 없다만
만약 그 findAll로 가져온 컬렉션을 반복문 안에서 사용한다고 하면
for 문 안에서 하나의 One마다 Many가 실행되기 때문에 별 차이는 없다.

결국 연관된 Many 오브젝트들을 제대로 가져오기 위해서는 다른 방법이 필요하다.

그 해결 중 하나는 페치 조인이라는 문법을 사용해서 JPQL을 직접 짜는 것이다.
join 대신 join fetch라는 구문을 넣어주면 즉시 연관된 Many 데이터들을 join해서 가져온다.

또는 @BatchSize라는 방법을 엔티티 내에 적어준다면,
알아서 where in 문법을 사용하여 적절하게 가져와 준다.

---
읽기 성능 최적화

데이터를 빠르게 읽고 싶다면 영속성 컨텍스트를 거치지 않는 방법이 좋다.
굳이 무거운 작업들과 메모리 사용을 할 필요가 없기 때문에 빠르다.
그러한 방법들은 다음과 같다.

1. select * from <> 이런 스칼라 타입 조회 쿼리를 쓰면 영속성이 관리하지 않게 된다.
2. 하이버네이트의 읽기 전용 쿼리 힌트를 사용한다.
3. @Transactional() 안에 스프링의 읽기 전용 트랜잭션 구문을 사용한다. 이는 자동 플러시를 멈춘다.

---  
트랜잭션과 락

JPA는 영속성 컨텍스트 덕분에 Repeatable Read 수준의 관리가 프로그램 내에서 가능하다.
JPA 내부에서 DB가 하는 일을 많은 부분 처리한다.

낙관적 락: 직접 테이블에 락을 걸기보다는 버전을 통해서 프로그래밍적으로 해결 
내부에 @Version 프로퍼티를 추가해서 관리한다. 
@Version만 있으면 낙관적락이 자동으로 걸리기는 한다.

비관적 락: 직접 락을 걸어서 해결. 

---
2차 캐시

영속성 컨텍스트는 생각보다 금방 사라진다.
트랜잭션 단위로도 사라지기도 하니까.

그래서 하나의 캐시를 더 두고 이것을 2차 캐시라고 부른다.
아마도 Ehcache를 비롯하여 Redis 같은 것도 사용이 가능한 것 같다.

DB와 영속성 컨텍스트 사이에 하나의 캐시가 더 있어서 이것을 활용할 수 있도록 한다.













  