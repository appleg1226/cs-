테스트 주도 개발 시작하기(최범균 저)
 
Chapter2. TDD 시작
- 테스트 코드에 대한 예시를 보아하니, 일단 테스트코드를 만들고, 그리고 그걸 실행시켜서 레드(테스트 실패)를 띄운다.
그리고 그것을 만족하도록 그린(테스트 성공)을 띄울만큼만 코드를 작성한다. 그리고 리팩토링을 진행하면서 코드를 고도화시킨다.
- 물론 TDD가 좋은 방식이고, 이것을 통해서 개발에 대하여 여러 이점이 있지만, 아직은 이렇게까지 해야하는지에 대해서 조금 의문이
드는 단계다. 아마도 직접 해보면서 느껴보지 않아서겠지라고 생각중이다.
 
Chapter3. 테스트 코드 작성 순서
- 예외 상황을 먼저 테스트해야 하는 이유. 이 주제를 보고 잠깐 TDD에 대하여 엄청난 기대감이 들게 되었다. 왜냐하면 개발을 하면서 
나는 일반적으로 예외 상황을 나중에 처리하고는 하는데, 이런 방법이라면 어떤 기능을 개발하더라도 덜 꼬이게 할 수 있을 것이라는
기대감이 들게 되는 중이다. 실제로 기능을 먼저 구현하고 예외 처리를 고려하느라 머리가 아팠던 적이 많았기 때문에 더더욱 관심이
생긴다.
- 너무 많은 코드를 한 번의 테스트에 작성하는 것은 좋지 않다. 한발자국씩 조심스럽게 나아가는 TDD에게는 확실히 차근차근히 테스트를
하는 것이 더 어울린다.(실제로 그게 더 견고하게 작성할 수 있고)
- 어떤 테스트를 돌릴지 미리 목록을 만들어놓고 쉬운 것부터 하나하나 만들어나가는 것이 좋다.
 
Chapter5. Junit5
- 처음보는 메서드
fail(): 테스트를 실패처리한다.
assertThrows(), assertDoesNotThrow(): 테스트가 예외를 던지는지 던지지 않는지 확인한다.
assertAll(): 람다를 이용하여 여러가지를 한번에 테스트할 수 있다.
assertEquals()에는 메시지라는 세번째 변수를 지정해줄 수 있다. 테스트가 실패했을 경우 해당 메시지를 실행한다.
 
- 어노테이션
@TestInstance(LifeCycle.PER_CLASS) : 원래는 모든 테스트를 진행할 때마다, Test 클래스가 새로 만들어진다.
만약 테스트 내부적으로 공통된 변수를 관리하고 싶을 때는 이 기능을 이용하여 클래스를 하나만 만들어줄 수 있다.
@TestMethodOrder(OrderAnnootation.class) + @Order(1), @Order(2)... :
앞의 어노테이션은 클래스의 앞에, 뒤의 어노테이션들은 각 메서드들의 앞에 달아준다. 테스트의 순서도 지정할 수 있다.
=> 그러나 위의 두 기능을 써서 테스트코드 간에 의존성을 만드는 것은 좋지 않다. 의존성은 유지보수를 어렵게 만든다.
 
@Disabled : 테스트 제외
@Tag : 태깅을 하면 이후에 메이븐/그레이들에서 테스트 대상을 선택하여 실행하거나 제외할 수 있다.
@Nested : 중첩 클래스에 지정한다. 상황별로 중첩 테스트를 분리해서 테스트를 작성할 수 있다.
@TempDir : 해당 어노테이션을 필등에 적용하면 테스트를 할 때 이 임시 폴더를 대상으로 파일을 만들고 지운다.
@Timeout(int time) : 시간을 지정하여 타임아웃을 설정할 수 있다.  
 
Chapter7. 대역(Test Double)
외부 API 사용, DB 호출 등 각종 테스트 외적 요인을 테스트하기 위해서는 아무래도 실제 데이터를 사용하기 보다는,
그것을 가상으로 만들어 놓고 테스트하는 경우가 자체 코드 테스트엔 효과적일 것이다.
그래서 기본적으로는 원래 사용하던 클래스를 상속하여 Stub 클래스를 만들고 그것을 이용해서 테스트를 진행하는 방법이 있다.
이것과 더불어 Mock은 기대한대로 동작하는지 행위를 검증하는 것이다. 
Mock을 쓸 것인지, 대체용 스텁을 사용할 것인지는 상황을 보고 판단해야 한다. 
Mock을 썼을 때 복잡해질 수 있기 때문에 이때는 스텁이 유리하다.

Mockito
- mock(someClass.class)로 객체 생성
- given(특정파라미터가 있는 메서드호출).willReturn(메서드반환)으로 해당 메서드를 호출했을 때의 반환값을 설정한다.
  .willThrow(exception.class or new Exception())를 사용하면 메서드를 호출했을 때, 예외를 반환한다.
- given에서 파라미터가 안맞을 경우, null을 리턴한다.
- 찾아보니 given과 when은 다른 패키지를 쓰지만 기능은 같다. 아무래도 스타일의 차이로 나눠놓은듯. 보통은 when을 쓴다.
- 메서드 파라미터값으로는 any()를 사용하면 어떤 파라미터도 해당 리턴을 실행하게 된다.
  이외에도 anyInt(), anyString(), anyList() 등이 있고 matches(string or pattern)으로 정규표현식도 쓸 수 있다.
- then(mock객체).should(호출횟수/여부).해당메서드() 를 쓰면 해당 mock객체가 메서드를 얼마나 호출했는지를 검사할 수 있다. 
  mockito 스타일에서는 verify(mock객체, 호출횟수/여부).해당메서드() 로 사용한다.

















