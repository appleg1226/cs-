네트워크 강의

* 네트워크는 여러 개의 프로토콜이 캡슐화되어 흘러간다.
ethernet - tcp - ipv4

* http 프로토콜은 7,6,5계층의 성격을 다 갖고있기는 하다.

* 패킷
패킷 = 헤더 + 페이로드 (+ 푸터)

Ethernet + (IPv4 + (TCP + HTTP))
각 프로토콜을 합친 것이 페이로드가 되고, 그 하위 프로토콜이 헤더가 된다.
패킷의 형태가 정해져있지 않다.
이렇게 반복해서 패킷을 포장하는 과정을 '캡슐화'라고 한다.
패킷을 받았을 때는 하나씩 반대 순서로 까면서 데이터를 확인하게 된다.

TCP+데이터 = 세그먼트
IPv4+세그먼트 = 패킷
Ethernet+패킷 = 프레임

* 2계층(Ethernet)
장비와 장비의 데이터 전달 과정. 흐름/오류 제어
다른 네트워크와의 통신에는 3계층이 필요하다.
MAC 주소로 통신 

이더넷 프로토콜 
= 목적지 맥주소 + 출발지 맥주소 + 이더넷타입(3계층 정보) + 데이터

* 3계층(IPv4, ICMP, ARP)
3계층은 랜과 랜의 데이터 전달을 담당한다.
멀리 가려면 3계층이 필요하다.
NAT: 공유기에서 내 기기로 데이터를 전달해주는 것
공유기는 요청이 나갈 때 NAT 테이블에 기록하고, 응답을 해당 기기로 받는다.
외부에서 사설 IP로 들어가려면 공유기에서 포트포워딩을 해야한다.
0.0.0.0 = wildcard = 나머지 모든 ip
127.0.0.1 = 자기자신.
게이트웨이 = 공유기 ip 대역 중 가장 작은 ip 또는 가장 큰 ip를 씀(ex 192.168.0.1)

* ARP(3계층)
같은 네트워크에서 통신을 하기 위해 필요한 MAC 주소를 IP주소를 이용해서 알아오는 프로토콜.

ARP프로토콜 = (a) + 출발지맥주소+출발지ip주소+목적지맥주소+목적지ip주소
a = 하드웨어타입(이더넷)+프로토콜타입(ipv4)+맥주소길이+ip길이+opcode(1 or 2)

arp 요청을 보낼 때는, 목적지 mac주소를 0으로 비워둔다.
ethernet에서도 목적지 mac주소를 모르니까 f로 채우게 된다.
f로 채운 것은 브로드캐스팅을 뜻하기 때문에 모든 네트워크에 보낸다.
모든 목적지는 각자 받은 요청을 까보고, ip 주소가 일치하는 것만 남기고 버린다.
그리고 arp 응답프로토콜을 보내는데 이번엔 브로드캐스팅이 아닌 직접 전달을 하게 된다.
그리고 받은 응답을 가지고 ARP 캐시테이블에 주소를 저장해 놓게 된다.

모든 통신의 시작 전에는 무조건 arp가 주고받아진 다음에 시작한다.

* IPv4(3계층)
네트워크 상에서 데이터를 교환하기 위한 프로토콜
데이터가 정확하게 전달될 것을 보장하지 않는다.
중복/순서 문제가 발생할 가능성도 있다.

IPv4 = version(=4) + 헤더길이/4(=5) + TOS(=0, 안씀) + 전체 길이
      + identification(순서) + flag(연속인지 아닌지)    
	  + fragment offset(패킷의 순서): 앞의 세 가지는 연속성과 관련된 정보이다.
	  + TimeToLive(1회 전달마다 1씩 줄어들게 설정.)
	  + Protocol(상위프로토콜, icmp/tcp/udp) + header checksum(헤더 오류 체크)
	  

* ICMP(3계층): Internet Control Message Protocol
ping에서 쓰는 프로토콜.
통신이 잘 되는지 확인하는 프로토콜이다.
아래와 같이 간단하게 이루어져있다.
ICMP = Type(icmp 유형) + Code + Checksum

* Routing Table
어디로 보내야 하는지 설정되어 있는 라우팅 테이블.
netstat으로 확인 가능.

내 컴퓨터에서 다른 컴퓨터와 통신할 때, 첫 요청의 ethernet 프로토콜에는
게이트웨이의 맥주소가 들어간다.
또 이 게이트웨이(공유기)에서 중간 전달지로 갈 때는 또 새로운 라우팅 테이블을 참조하여
새로운 이더넷 프로토콜을 만든다. 
중간 전달지에서 다시 이더넷을 짜고, 도착할 때까지 새롭게 이더넷 프로토콜이 생성되는 것이다.
즉 여러 번의 이더넷 프로토콜의 생성이 발생한다.

* IPv4의 조각화
큰 페이로드가 있는 데이터는 패킷이 조각화가 이루어지게 된다.
내가 보내려는 데이터가 크면 그것을 장비에서 잘라서 보내게 된다.
이 때 위의 flag, offset을 프로토콜에 각자 지정하게 된다.
결국 id는 같고 flag, offset이 다른 여러 개의 패킷이 생기게 된다.

* 4계층(포트번호)
포트번호: 특정 프로그램이 사용하는 주소.

* UDP(user datagram protocol)
전송 방식이 너무 단순. 문제가 생겨도 무시한다.
udp = source port + dest port + length + checksum
dns 서버, tftp 서버가 udp를 사용한다.
파일 전송에 사용하기에 좋지는 않다. 스트리밍 서비스에는 좋다.

* TCP(transmission control protocol)
안정적, 순서대로, 에러없이!

tcp = source port + dest port + sequence number + ack number
     + offset(헤더길이) + reserved(안씀) + flag + window + checksum
	 + urgent pointer + tcp options

tcp flag: C E U A P R S F 의 종류가 있다.
tcp가 계속해서 연결상태를 물어보는데 그 때의 상태를 표현하며,
연결 중인지, 종료인지, 초기화인지, 보내는건지 등을 여기에서 설정한다.
U(urgent), A(ack, 핸드셰이크용), P(push), 
R(reset, 연결 관계 초기화), S(sync, 동기화. 연결을 시작할 때 무조건 사용), 
F(fin, 종료 비트)

* tcp 3way handshake
1. 클라이언트가 서버에게 요청 패킷을 보내고(eth+ipv4+tcp(syn))
2. 서버가 클라이언트의 요청을 받아들이는 패킷을 보내고(eth+ipv4+tcp(ack+syn))
3. 클라이언트는 이를 최종적으로 수락하는 패킷을 보낸다.(eth+ipv4+tcp(ack))

* tcp 통신 과정
1. 보낸 쪽에서 또 보낼 때는 SEQ, ACK 번호가 그대로이다.
2. 받는 쪽에서 SEQ 번호는 받은 ACK 번호가 된다.
3. 받는 쪽에서 ACK 번호는 받은 SEQ 번호 + 데이터의 크기 

SEQ 번호와 ACK 번호들을 이용해서 데이터의 연결 상태, 현재 전송 상태를 유지한다.

LISTEN 상태: 포트번호를 사용하고 있는 상태. passive open
ESTABLISHED 상태: 연결이 서로 수립이 된 상태. 능동적 open

* NAT(Network Address Translation)
IP 패킷의 TCP/UDP 포트 숫자와 소스 및 목적지의 IP 주소 등을 재기록하면서
라우터를 통해 네트워크 트래픽을 주고 받는 기술을 말한다.
체크섬도 다시 계산한다. 이것을 이용해서 사설 IP가 공인 IP를 사용할 수 있게 된다.
꼭 여기에만 쓰는 기술은 아니다.

* 7계층(HTTP)
이미 알고 있으며, 간단해서 생략





























