데이터베이스 튜닝과 관련된 정리

DB의 동작은 SQL을 이용해서 일어난다.
이전에는 여기까지만 생각했었다.
내가 날린 쿼리가 그대로 실행이 되는구나. 라는 생각을 했었는데 
이 책을 통해서 배운 바로 DB는 하나의 프로그램이라고 보는 것이 맞는 것 같다.

쿼리라는 선언적인 언어를 DB 시스템에 보내면 DB 내부적으로는
1. 파서의 파싱
2. 옵티마이저의 최적화
3. 로우 소스 generator의 출력 포맷팅

이런 식으로 이루어진다.

옵티마이저는 내가 날린 쿼리를 내부적으로 어떤 방법을 통해서 실행할지를 결정한다.
그것을 직접 확인하는 것이 진정 데이터베이스의 성능을 최대한으로 올릴 수 있는 방법이다.

책에서는 옵티마이저가 마치 네비게이션처럼 여러 경로를 파악할 수 있다고 설명하고 있다.

---
SQL의 성능의 알파와 오메가는 I/O 때문이라고 한다.
즉 디스크에서 얼마나 데이터를 읽어내야 하느냐의 문제다.

쿼리를 날렸을 때 디스크에서 모든 테이블의 데이터를 읽어야 한다면 그 동안 I/O가 발생하여
기다리는 시간이 많아질 것이다.

그런 것을 대비해서 버퍼 캐시가 있으며 여기에서 데이터를 읽어오면 
엄청나게 빠른 속도로 읽어올 수 있기 때문에 담겨있어야 좋다.
---

특히 내부적으로 데이터를 탐색할 때, 인덱스를 사용하는 것은 속도를 높여주는 것으로 알려져 있다.
본인이 빠르게 찾고 싶은 데이터를 인덱스를 이용하면 된다.

그런데 인덱스를 걸어도 full scan을 하는 경우가 있고,
인덱스를 걸어서 검색하는 것보단, full scan을 하는 것이 더 나을 때도 있다.

인덱스를 제대로 사용하려면 인덱스의 구조를 제대로 알아야 한다고 한다.
그런데 공부해보니 그게 맞았다.

만약에 6개의 반에서 홍길동을 찾으려면
교무실에서 이름 목록을 받아서 홍길동을 찾으러 가는 것이 빠르다.

그런데 그 중에서 키가 160대인 사람을 찾으라고 하면 인덱스에서 찾는 것보다도
직접 모든 반을 도는 것이 빠를 수도 있다.

찾고자 하는 데이터가 한 번에 많이 발생한다면 인덱스를 사용하기보다는 
직접 돌아보는 것이 효율적이다.

--- 

인덱스를 가공하면 정상적으로 사용할 수 없다.
이 말이 거의 db에서는 명제라고 한다.

인덱스를 가공해서 substring, like "%name%" 이런 식으로 가공을 해서 찾아 버리면 의미가 없다.
왜냐하면 정렬은 저 가공된 형태로 되어 있는 것이 아니기 때문.

여러 개로 이루어진 인덱스는 그 순서가 중요하다.
팀 / 이름 / 나이
일 때 같은 이름이어도 멀리 떨어져 있기 때문에 
이름을 기준으로 찾는다면 의미가 없다. 결국은 full scan을 하게 된다.
그래서 순서가 중요하다. 

---

인덱스는 비싸다.
인덱스를 통해서 테이블을 조회하는 것은 고비용이다.
아무래도 바로 주소값을 가리키는게 아니라 캐시에서 찾아보고 그 내부적으로도 
참조가 여러 단계로 얽혀있다. 그래서 직접 찾아가는 것보단 훨씬 느리다.

CF(clustering factor) 인덱스 데이터의 군집도가 높을수록, 즉 모여있을수록
인덱스를 이용한 조회가 빠르다.

이게 좋으면 인덱스를 사용해서 많은 데이터를 조회하더라도 성능의 문제가 덜하다.
즉 이 CF에 따라서 인덱스를 사용하는 것의 손익분기점이 결정된다.

---

트랜잭션 쪽을 보면 sql에 락을 얼마나 기다릴 것인지에 대한 설정을 할 수 있다.
비관적 동시성 제어는 모든 것을 부정적으로 보아 완전히 락을 제어한다.
즉 트랜잭션을 시작한 데이터는 락이 걸린다.

반면 낙관적 동시성 제어는 lock이 유지되는 시간이 짧아진다.
sql에서 직접 lock에 대한 설정을 하는 것이 아니라,
만약 칼럼 중 하나를 통해 변경에 대한 여부를 체크하는 것이다.
보통 시간을 체크하거나 한다.